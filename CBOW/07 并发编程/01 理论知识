https://www.cnblogs.com/Dominic-Ji/articles/10929381.html

一、多道技术：

单核实现并发的效果
ps：这里单核指的是一个核，干活的就是一个，不考虑CPU内部的内核数

必备知识点：

1、并行和并发
并发：看起来像同时运行的可以称之为并发
并行：真正的同时进行

那么并行一定并发
单核的计算机肯定不能实现并行，但是可以实现并发！！！

2、多道技术图解
（一条路）串行===》（多条路的并行）
在A分析指令时可以去取B的指令了，就是不用等一条指令执行完

重点知识点：

3、空间复用和时间复用
空间复用： 多个程序用一个硬件设备
时间复用：一边...一边...
（切换+保持状态）

'''
切换（cpu）分两种情况：
    1、当一个程序遇到了IO操作时，操作系统会剥夺该程序的CPU执行权限
    作用：提高了CPU的利用率，并且也不影响程序的执行效率
    2、当一个程序长时间占用CPU的时候，操作系统会剥夺该程序的CPU执行权限
    作用：降低了程序的执行效率（原本时间多了切换时间）

单核的时候就只能等，谁拿到谁用，没拿到干等
'''

二、进程理论：

必备知识点：

1、程序和进程的区别
程序：就是一堆躺在硬盘上的代码，是“死”的
进程：表示程序正在执行的过程，是“活“的 （在内存中哦~）

2、进程调度
   想要多个进程交替运行，操作系统必须对这些进程进行调度，但是这些调度也不是随机进行的，
需要遵循一定的规则，因此就有了进程的调度算法

进程的调度算法：（可以试着去实现一下）
1）、先来先服务算法：对长作业有利，对短作业无益
2）、短作业优先调度：对短作业有意，对长的无益（CPU自己会判断谁长谁短）
3）、时间片轮转调度 + 多级反馈队列
（与时间和优先级都有关系）

3、进程运行的三状态图：
https://www.cnblogs.com/Dominic-Ji/articles/10929384.html
所有的程序想要被执行必须经历就绪态

4、两对重要概念

 4.1 同步和异步： (描述的是任务的提交方式)
   同步：任务提交之后，原地等待任务的返回结果，等待过程中不做任何事情（干等）
         程序上表现就是卡住了
         代码解释：
         '''
         def func():
            pass
          res=func()  #在这里就是同步调用,也就是说我要拿到func()函数的返回结果，我才能去执行下面的动作
          print(res)
         '''
    异步：任务提交之后，并不会在原地等待任务的返回结果，依然可以去做其他事情
         那么可能会带来一个疑问：我提交完任务后离开了，那我如何获取任务结果呢？
         任务的返回结果会有一个异步回调机制自动处理

 4.2 堵塞和非阻塞：（描述的是程序或进程的运行状态）
    阻塞：阻塞态
    非阻塞：就绪态、运行态

上述概念的组合中，最高效的一组组合状态是：异步+非阻塞


'''
来一个小插曲吧：平常写代码时还是应该注意代码规范，面试可能会看哦~
'''

5、开启进程的两种方式：
    是代码呀~，看文件"02 开启进程的方式"
    1、类的实例化产生对象
    2、类的继承 run方法（不能改）

    总结一下：
        创建进程就是在内存中申请一块内存空间，将需要运行的代码丢进去
        一个进程对应在内存中就是一块独立的内存空间
        多个进程对应在内存中就是多块独立的内存空间
        强调独立：因为进程与进程之间的数据在默认情况下是无法直接交互，如果想交互可以借助与第三方工具、模块


    关于 if  __name__ == '__main__' 的一点解释：
        当.py文件被直接运行时，if __name__ == '__main__'之下的代码块将被运行
        当.py文件以模块形式被导入时，if __name__ == '__main__'之下的代码块不被运行

6、join方法
X.join:是为了让主程序等待X这个子进程结束后在执行

7、验证进程之间的数据是相互隔离的


'''
推荐：人工智能参考资料
百度api
图灵机器人 （自动聊天）
科大讯飞 （语言识别）
智能创作平台 （百度的） https://ai.baidu.com/creation/main/index

以及pycharm过期激活：
http://idea.medeming.com/jets/
'''

内容：
    进程对象及其他方法
    僵尸进程和孤儿进程
    守护进程
    互斥锁
    队列介绍
    进程间通信IPC机制
    生产者消费者模型
    线程理论

一、进程对象及其他方法

 储备知识：
    一台计算机上可能运行着很多进程，那么计算机是如何区分并管理这些进程服务端的呢？

    解决：计算机会给每一个运行的进程分配一个PID号
    如何查看：
        windows系统：
            查看全部进程号：进入cmd  输入 tasklist 即可查看
            查看指定进程号：tasklist | findstr PID
        mac系统：
            查看全部进程号：进入终端 输入ps aux
            查看指定进程号：ps aux|grep PID

 查看进程的两种办法：
    1、
        from multiprocessing import Process, current_process
        current_process.pid()
    2、
        import os
        os.getpid()  #查看当前进程号
        os.getppid() #查看当前进程的父进程

        嵌套关系：

        Pycharm.exe进程下：
            进程对象和其他方法.py进程:
                主进程
                    子进程

 其他方法：
    p.terminate() # 杀死当前进程
    p.is_alive() # 判断当前进程是否存活
    """
     1、小知识:
        一般情况下，我们会将
                存储布尔值的变量名 和
                返回结果是布尔值的方法名 都起成 is_开头
     2、易错点：
           p.terminate() # 杀死当前进程
           # time.sleep(0.1)
           print(p.is_alive())

        如果刚刚杀死就判断，可能结果为True,因为操作系统去执行那个命令需要时间，但代码运行速度有非常快
        解决办法：在杀死当前进程后，给操作系统留一点时间（也可以在其他地方判断）
    """

二、僵尸进程与孤儿进程（了解）

三、守护进程

四、互斥锁

多个进程操作同一份数据的时候，会出现数据错乱的问题
对于数据错乱，解决办法就是加锁处理：
    将并发变成串行，牺牲效率但保证了数据的安全性

from multiprocessing import Process, Lock
在主进程中生成锁，随机抢锁
mutex 要作为参数传递

但是这个东西以后代码会有封装好的东西，不用自己写

如果想不明白，可以想一下几个人一起抢厕所
一个人抢到了，需要把门锁上，不能一起进去

扩展：
    行锁、表锁
    保证数据安全时要用锁
注意：
    1、锁不要轻易使用，容易造成死锁的现象（一般并不会用到，都是封装好的）
    2、锁只在处理数据的部分加入，来保证数据的安全（争抢数据加锁处理）

"""
复习：
    json格式的文件也可以充当数据库

不加s，处理的是文件
json.load(): 从json文件中读取数据，str--->dict
json.dump(): dict--->str 保存到json文件中

加s，处理的是数据
json.loads():
json.dumps():

# 写入 JSON 数据
with open('data.json', 'w') as f:
    json.dump(data, f)

# 读取数据
with open('data.json', 'r',encoding='utf-8') as f:
    data = json.load(f)
"""


五、进程间通信

储备知识：
    我们之前说过，进程与进程之间是独立的，互不影响的，那么如何让两个进程之间进行通信呢？
    1、两个进程之间可以建立管道(subprocess)
    2、可以新开辟一块空间，都经过那一块空间便可通信
    用到的技术为队列，Queue模块

    队列=管道+锁
'''
复习：
    import 与 from ...import的区别
'''

六、IPC机制：进程与进程之间的通信(演示)

    1、主进程和子进程借助于队列通信
    2、子进程和子进程借助队列通信

七、  生产者消费者模型(蛮重要的)
    生产者：生产/制造东西的
    消费者：消费/处理东西的
    该模型除了上述两个之外还需要一个媒介：
       例子：
        厨师做完菜需要用盘子装在给消费者端过去

       生产者(厨师)+消息队列(盘子)+消费者(顾客)

    (emmm,再看一遍吧)

八、线程理论

1、什么是线程
    进程：资源单位(起一个进程仅仅只是在内存空间中开辟一块独立的空间)
    线程：执行单位(真正被CPU执行的其实是进程里面的线程，线程指的是代码的执行过程)
    线程在执行的过程中所需要使用到的资源都来自所在的进程


    将操作系统比喻成一个大的工厂
    那么进程就相当于工厂里面的车间
    而进程就是车间里面的流水线

    每一个进程肯定自带一个线程

    进程和线程都是虚拟单位，只是为了我们方便描述问题

2、为什么要有线程

    开设进程的步骤；
        1、申请内存空间  耗资源
        2、“拷贝代码”   耗资源

    开线程：
        一个进程内可以开设多个线程，在同一个进程内开设多个线程时不需要再次申请内存空间和拷贝代码了

    总结：
        开设线程的开销要远远小于进程的开销
        同一个进程下的多个线程，数据共享


    例如：我们要开发一款文本编辑器，功能有：
        1、获取用户输入的功能
        2、实时展示到屏幕的功能
        3、自动保存到硬盘的功能
    针对上面的三个功能，开线程更加合理一点，因为数据共享
        (三个线程三个功能)

3、如何使用


今日内容概要：
    开启线程的两种方式
    TCP服务端实现并发的效果
    线程对象的join方法
    线程间数据共享
    线程对象属性及其他方法
    守护线程
    线程互斥锁
    GIL全局解释器锁
    多进程与多线程的实际应用场景


8、GIL全局解释器锁：
python解释器有多个版本
    Cpython
    Jpython
    Pypypython
   但是普遍使用的是Cpython解释器

在CPython解释器中GIL是一把互斥锁，用来阻止同一个进程下的多个线程同时执行
也就是说：同一个进程下的多个线程无法利用多核优势

疑问：python的多线程是不是一点用都没有？？？

首先解释，无法利用多线程的原因：
     因为C-python中的内存管理不是线程安全的
     C-python中有内存管理机制(垃圾回收机制)
         1、引用计数
         2、标记清楚
         3、分代回收

      重点：(图解看word文档，重要~~~)
        1、GIL不是python解释器的特点，而是C-python解释器的特点
        2、GIL保证的是解释器级别的数据安全（因为锁是给解释器加的）
        3、GIL会导致同一个进程下的多个线程无法同时进程
        4、针对不同的数据还是需要加不同的锁处理
        5、解释型语言的通病：同一个进程下多个线程无法利用多核优势
             原因：解释型语言是一行一行执行的，并不知道代码的整体

















